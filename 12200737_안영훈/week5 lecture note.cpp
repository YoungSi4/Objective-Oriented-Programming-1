// 5주차 강의노트 1 - 반복문
// 
// 이제부터 진짜 연습을 안 하면 따라오기 힘든 내용의 시작.
// 
//  1. 연산자
// L - value, R - value -> 등호를 기준으로 왼쪽 오른쪽
// L : 수정할 수 있는 객체
// R : 수정할 수 없는 값
// a = 5; 됨
// 5 = a; 안 됨
// a = 3+5; 됨
// 
// 즉, LV는 값을 저장할 수 있는 공간
// a = b; 가능함
// 
// RV는 표현식이 종료된 이후에 존재하지 않는 값.
// 
// 
// 1 - 1. 전위 후위 연산자
// a = 1 + a;
// a = a + 1; 과 다소 다르다.
// 
// 전위. 
// 피연산자 변수 값 1 증가
// 변수 자체를 리턴 (L value)
// 
// int a = 5;
// cout << ++a; -> 6 출력
// 
// >>	int a = 5 > a = 6으로 변경 ( 변수 자체가 1 증가 )
// >>	a 를 ++a 자리에 둠
// 
// 후위
// 변수의 값 저장
// 변수 값 1 증가
// 저장된 값을 리턴 (R value)
// 
//		a를 일단 임시 저장
//		변수 값 1 증가
//		저장된 값 리턴
// 
// int a = 5;
// cout << a++; -> 5 출력
// 
// int a = 5;
// cout << a++ -> 5;
// 
// int a = 6;
// cout << 5; // 후위 연산 결과.
// 
// ++(++a); 는 되는데
// ++(++a) -> 괄호 안이 ++a 가 됨
// (a++)++; 는 안 된다. (a++)는 R value가 되기 때문
// 16++ 와 동일해짐.
// 
// 다른 건 몰라도 5p의 예제를 꼭 참고하자
// 
// do while은 사실 while의 특수한 형태에 가깝다.
// 
// 조건문은 크게 두 가지로 나눔
// 1. 카운터 제어 반복문 (횟수)
// 2. 이벤트 제어 반복문
// 
// 
// list 초기화.
// 
// 다양한 초기화 방식.
// int a = 1;
// int a(1); -> 특정 문법이 특정 대상에 따라 안 되기도 함.
// int a = { 1 };
// int a{ 1 }; -> uniform 초기화 혹은 리스트 초기화라고 부름
// 
// 근데 이게 되는 컴파일러가 있고 아닌 컴파일러가 있음.
// 
// 
// 기능적으로 다른 게 있을까
// int x = 5.16; -> x == 5; // 축소 변환이라고 함, 암시적 변환이 나중가면 골치아픔
// int x(5.16); -> x == 5...?
// 
// int x = { 5.16 }; 안 됨. 막아뒀음.
// 
// int a = 5;
// int b;
// b = 5; // 생성할 때 선언해주는 걸 초기화라고 함
// 
// int a{ 5 };
// int b;
// b{5} 안 됨. 이 문법은 초기화할 때만 가능
// 
// 이벤트 제어 반복문의 한 종류
//	센티넬 제어 반복문. 감시병, 보초병, 파수꾼.
//  
//  -1은 값으로서 의미가 있는 게 아닌
//  여기까지를 입력으로 보겠다는 의미임.
// 이런 뜻에서 sentinel이라는 이름이 붙었음
// 
// 이벤트 제어 반복문의 한 종류22
// EOF 제어 반복문.
// 파일을 다 읽고 나면 EOF 상태가 됨.
// 윈도우에서는 ctrl + z : ^Z 로 표시됨
// 리눅스 맥은 ctrl + d
// cin도 while문 조건에 올 수 있다.
// 
// 제대로 입력되면 true,
// 사용자 입력에 실패하거나 eof 입력이면 false가 된다
// 
// 이벤트 제어 반복문의 한 종류333
// 플래그 제어 반복문
// 
// 컴퓨터 시스템의 플래그? - 어떤 특정 상태를 저장하기 위한 것
// 0 or 1 으로 저장함. 플래그 비트라고도 함
// 
// flag를 1로 초기화 해두고 반복문 조건에 넣는다.
// 특정 조건이 되면 flag를 false로 바꾸고 탈출하는 방식
// 이 강의에선 사용하면 안 된다.
// 
// 무한 루프 -> 종료 조건이 없으면 계속 돌아간다.
// break를 이용해서 탈출할 수 있다.
// 굉장히 직관적이고 쉽게 만들 수 있긴 하다.
// 이 강의에서 그렇게 쓰면 안 된다.
// 
// while (1), while(true), while(flag)
// 일단 반복을 돌려두고 중간에 조건을 삽입해서 탈출하지 말라는 뜻.
// 이런 식으로 작성하면 논리 표현식을 만드는 연습을 못 한다.
// 
// while ( a || b && flag ) 이런 건 됨.
// 논리식 만드는 연습이기 때문.
// 
// for 부터는 내일!
// 
// 
// 
// 
// 
// 
