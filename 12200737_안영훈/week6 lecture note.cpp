// 6주차 강의노트 - 함수 파트 1

// 시험 관련 공지
// 
// 시험 유형
// ~~ 한 결과를 반환하는 코드 작성
// 이 코드의 결과를 작성
// ~~ 한 함수를 작성하시오
// 이 코드에서 틀린 부분을 작성하시오 (이게 어려울 듯?)
// ㄴ수동 디버깅 미쳤음...
//  
// 시험시간에 문제 관련한 질문은 받지 않는다.
// 시계는 알아서 챙길 것...
// 첫 퇴실자가 생긴 이후로는 시험 재입장 가능
// 늦을 것 같으면 교수님 이메일 보낼 것.
// 늦참할 때까지 퇴실 통제할 예정
// 
// 일단 lab 코드 다 한 번씩 풀어보고
// 빈 종이에 코드를 작성하는 식으로 연습해볼 것
// if for 함수 이렇게 셋 위주로 해보고
// 혹시 모르니 iomanip 라이브러리 사용하는 내용도 한 번 볼 것




// 본격적인 함수 내용 시작
// 
// 함수?
// 기능을 하나 묶어서 만들어두는 것.
// 
// 라이브러리 함수 - C++에선 STL 등
// 1. cmath
// abs : 절댓값
// pow랑 sqrt 정돈 알고 있자
// 
// 2. ctime
// time 함수 딱 하나만 사용할 예정
// time(0) : 유닉스 타임이라는 걸 얻을 수 있다.
// 유닉스 타임 1970 1월 1일 0시부터 현재까지 몇 초가 지났는지 센 시간
// 
// 함수 이름( 입력값 )
// 함수를 호출했던 자리에 리턴값을 돌려줌
// 
// time(unsigned NULL)로 호출하는 게 더 좋다?
// time(0) 으로 해도 된대요
// 
// 참고로 6p의 예제는 영국 표준 시를 반환해준다.
// 
// *** - (Pseudo) Random Number ***/
// Psuedo : 가짜, 의사 / 의사코드 말하는거 맞지?
// 진짜는 아니긴 한데, 진짜 그런 것처럼 동작한다.
// 
// 컴퓨터를 이용한 Random Number는 무작위라는 개념을 구현할 수 없음
// 논리 덩어리니까!
// 이걸 구현하기 위해 수식을 이용함.
// 무작위하게 보이도록 만드는 것일 뿐임.
// 컴퓨터에선 동일한 상황에서 돌리면 동일한 값이 나온다
// 이런 걸 막기 위해 여러 통계적 기법을 도입한다.
// 
// ex) 확률에 맞게 이미 숫자가 적힌 테이블이 존재
// 시작위치를 매번 다르게 하면? - 자동으로 다른 값이 들어간다.
// 
// srand() - rand 함수의 시작위치를 정하는 함수
// 시작 위치를 seed라고 한다.
// seed 값? 마크 맵 생성의 그 seed 값 맞습니다.
// 
// 무작위한 숫자를1 ~ 6까지만 나오도록 1 + rand() % 6
// 
// 일종의 공식?...
// 6개의 난수를 원해용
// 
// temp = rand() % (b - a + 1)
// ㄴ-> 나누는 숫자가 만들고 싶은 숫자의 범위
// result = temp + a
// 
// 5 ~ 15 사이의 난수를 생성
// 숫자를 하나씩 입력해서 맞추는 예제
// 
// srand(time(0)) -> 가장 쉽게 난수를 만들 수 있는 방법
// 근데 문제가 있음...
// 
// srand(time(0)) 를 무한 반복문에 넣고 돌리면.
// 1초에 반복문이 수도 없이 많이 돌아간다.
// time(0) 함수는 1초마다 바뀌니까
// 
// 1초동안 무작위가 아닌 고정값을 계속 던져준다.
// 
// 그냥 반복문 밖에 써버리자.
// time 함수로 seed를 할 때는 적절한 위치에 쓰도록 하자.
// 
// 
// 
// 
// 
// 
// 
// 
// 함수
// 하나의 특정한 작업을 수행하기 위해 설계된 코드의 집합.
// 하나만 들어가도록 설계해야 한다. SOLID
// 
// int output() {
//	return()
// }
// 
// int input(){
//	output()
//	return
// }
// 
// main() {
//	input()
//	return 0;
// }
// 순서에 유의
// 
// 함수 선언
// 
// int sum(int num1, int num2) -> 헤더, 프로토타입 {
// 
// } -> 바디
// 
// 헤더 + 바디 -> 함수를 선언한다
// 
// 헤더만 선언할 수도 있다.
// 이런 걸 함수 전방 선언, 함수 프로토타입이라고 한다.
// 
// 
// - 매개변수와 인자
// Parameter 매개변수 : 함수 정의부에서 선언된 변수
// L value?
// 
// 
// Argument 인자 : 함수 호출 시 전달되는 값
// R value? 
// 
// ㄴ 전혀 상관없는 개념임.
// 
// 애초에 이름이 "변수"
// value는 값인거니까.
// 
// 다음 시간에
// pass by value
// pass by reference
// pass by pointer를 듣고 생각해보자.
// 
// 
// 매개변수와 인자는 변수의 선언과 초기화 구문으로 이해하자.
// 
// int func1(int a, int b) {
// 
// }
// 
// func1(5, 6)
// ㄴ-> int a = 5, int b = 6 이 func1 스코프 내에서 내부적으로 실행된다.
// 나중에 함수 매개변수로 포인터나 참조자가 올 때 이걸 상기해보자.
// 
// - return
// 함수를 호출한 자리에 return 옆의 값을 전달해준다.
// 최종적으로 함수가 호출됐던 자리에 return값이 들어온다.
// 나중에 포인터, 참조자, 재귀를 배우고 나면 뭐가 리턴값인지 알기 어렵다.
// 
// - 각각의 함수 영역은 독립이다. 스코프!!!!!
// 전역변수면 모를까.
// 근데 거의 못 쓰게 함 전역 변수
// 
// 
// 함수 프로토타입은 왜 쓰는걸까?
// 6주차 강의노트 12p
// 왼쪽코드는 작성하면 컴파일 에러가 발생한다.
// avg 함수 내의 sum 함수가 있는데,
// sum 함수가 정의되지 않았으니까.
// 
// sum 함수를 avg 위를 올리면 해결됨.
// 근데 이게 좋은 방법일까?
// 
// 함수가 50개 100개가 있으면?
// 50개의 함수를 일일이 순서를 다 알고 있어야 할까?
// 상황에 따라 내가 원하는 식의 순서로 못 놓는 경우도 있다.
// 
// ex) fun1 fun2 가 서로를 호출하면?
// 이건 불가능 함.
// 따라서 프로토타입을 이용하는 것임.
// 
// 프로토타입은 이런 이름의 식별자가 어떤 값을 받는지 정도만
// 미리 컴파일러에게 알려주는 것.
// 변수를 지정하지 않아도 됨.
// 
// double fun2 (int, int) -> 정수 2개 받을거임.
// 정도로도 가능하다.
// 
// 변수 이름을 다르게 해도 됨.
// 
// double fun2(int a, int b) -> 컴파일러는 매개변수의 식별자(이름)을 읽지 않는다.
// 
// double fun2(int num1, int num2){
// 
// }
// 이런 식임.
// 물론 가독성을 위해서 변수명을 맞춰주는 게 좋다.
// 
// 함수 사용은 꼭 손에 익히는 게 좋다.
// 백준에서야 시간 제한 상 안 쓰지만
// 실제로는 써야한다.
// 
// 
// - 코딩할 때 알아둬야 할 것
// 
// 1. 중복코드 피하기
// 이 코드를 수정해야 한다면?
// -> 이거 여기저기 흩어진 코드를 다 찾아가서 수정해야함.
// 함수를 쓰자 함수!
// 
// 2. 디버깅
// 한 줄씩 검사하면서 코드의 흐름을 원하는대로 제어할 수 있음.
// 함수 단위 (기능 단위로) 코드를 나눠두고
// 각각 디버깅을 하면 깔끔해진다
// 
// 섞여있으면 어느 기능이 문제인지 절대 모름...
// 
// 3. 분할 처리 (Divide and Conquer)
// 
// 
// 
// 함수 사용의 단점?
// 코테에서 호출 오버헤드로 인해 시간이 조금 더 걸린다.
// 근데 그거 외엔 없음
// 1가지 단점이고 남은 모든 게 장점임.
// 
// 
// 과제 설명
// 승점 5점으로 해두고.
// 나희도 선수의 행동은 내가 선택하고
// 고유림 선수의 행동은 컴퓨터가 선택한다.
// 
// 판정
// 막기 > 베기
// 베기 > 찌르기
// 찌르기 > 막기 (가위바위보임)
// 
// 이긴 쪽의 승점을 올리고
// 비기면 승점 변화가 없음
// 둘 중 한 명이라도 승점에 도달하면,
// 
// 이긴 선수 금메달을 출력해주자.
// 
// 무작위 숫자가 같은 패턴이 나오지 않도록 설정해야 한다.
// 난수 생성을 포함하는 프로그램은 테스트가 어렵다...
// 테스트를 쉽게 할 수 있는 기술이 있긴 한데,
// 직접 한 번 생각해서 적용해보자.
// 
// 의미있는 함수를 두 개 이상 만들고 사용한다.
// 적어도 하나 이상은 매개변수를 가지고
// 모든 함수는 프로토타입을 사용한다.
// 
// 다음주는 과제가 없다! 와!
// 
// 