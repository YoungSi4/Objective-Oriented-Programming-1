// 7주차 강의노트 - 함수 2
// 
// 함수 시그니처
// 함수명 + 파라미터의 자료형으로 저장한다
// **리턴타입은 인식하지 않는다.
// 
// 함수가 받은 인자가 자료형이 딱 맞아 떨어지는 게 없으면?
// 끼워넣을 수 있는 걸 찾아서 넣는다.
// 근데 모호하면 그냥 에러를 반환한다.
// 
// 프로그래밍에서 모호한 상황은 모두 에러를 반환한다.
// 
// 
// 함수 프로토타입은 함수의 스코프를 끌어준다는 개념으로 접근해도 좋다
// 
// 
// 전역변수는 절대 쓰지 마시오
// 근데 써도 되는 상황이 아주 가아아아끔 있다고 함
// 
// 
// 
// 정적 지역 변수?
// 함수 내부에서 되긴 하는데, 지역이 사라져도 소멸되지 않는다
// 프로그램이 끝나야 소멸된다.
// 초기화는 한 번만 가능.
// 
// 섀도잉 - 변수 가리개
// 가려진 전역변수에 접근 ::
// 가려진 지역변수에 접근???
// 애초에 코드를 이렇게 안 짜면 된다.
// 
// 
// 

#include <iostream>
using namespace std;

int& sum(int num1, int num2) {
	int sum = num1 + num2;
	return sum;
}


int main() {
	int& a = sum(5, 16);
	int& b = sum(2, 12);
	cout << a << endl;
	cout << b << endl;
	cout << a + b << endl;

	return 0;
}

// 애초에 이런 코드는 확실성을 보장하지 않기 때문에 안 쓴다
// 
// 이건 변수 스코프를 저장하는 stack이랑 연관이 있는데,
// sum을 두 번 연달아 호출했기 때문에 이 코드에서 두 값이
// 동일한 위치에 저장됐을 뿐이지,
// 만약 여러 함수를 섞어서 했다면 다른 결과가 나올 수 있다.
// 이제 동일한 결과를 보장하지 않는다는 말이 어떤 의미인지 알겠는가?
// 
//





// 7주차 강의노트 함수 2 - 2
// 
// 함수 리턴 자료형 앞에 inline을 붙이면?
// 
// 원래 함수는 코드 읽는 흐름이 함수로 갔다가 돌아오는 식인데,
// inline을 하면, 함수를 호출한 자리에 함수의 내용을 그대로
// 복사 붙여넣기 해서 코드를 돌리는 방식이다.
// 
// 차이점? 함수 호출이 없어진다. (즉 호출 오버헤드가 사라진다)
// 
// 장점: 함수의 기존 장점은 그대로 가져간다.
// 거기에 오버헤드가 없다는 장점.
// 
// 일부 기능은 inline으로 안 적어도 스스로 적용시키기도 한다.
// 
// const double& side? **********************************
// pass by ref 에서 const를 붙이는 경우
// 
// 정식 이름
// int&: Lv ref
// int&& Rv ref
// 하나는 L 밸류만, 두 개는 R 밸류만 호출 가능
// 
// int& r = 5 -> 오류 발생
// const를 앞에서 붙여줘야 한다.
// 
// 1.
// 2. Rv여서 사라지기 때문에 const를 붙여줘야 한다.
// 복습합시다. 17p 매우 중요.
// 
// 수정할 일이 없는 경우엔 const를 붙이는 게 좋은 습관이다.
// 
// 파라미터를 const int& a 로 해뒀는데
// 함수(3.5) 로 호출하면...? 에러가 난다
// &&로 호출해야함. Rv니까.
// 
// 재귀 첫 페이지는 건너뛰고 두 번째 페이지로 설명
// 인셉션!
// 
// 풀기 시작하는 시점이 있어야 한다 (base case)
// 인셉션의 림보 ㅋㅋ
// 
// 오른쪽 숫자가 0이 아니면 왼쪽에 둔다
// 왼쪽 숫자를 옮겼던 숫자를 옮긴 것을 아래 왼쪽의 나머지를 쓴다.
// 
// 유클리드 머시기 방법? (최대공약수)
// 
// 피보나치 재귀!
// 
// 
// 반복과 재귀
// 
// 재귀 : 베이스 케이스만 작성하고 반복 규칙을 그대로 작성하면 된다.
// 즉, 재귀의 규칙만 정하면 코드 구현이 쉽고, 사람이 읽기 쉽다.
//  대신, base case 리턴 전까지 유지해야 하는 정보량이 크다.
// 중복 실행도 있고, 오버헤드도 크다.
// 
// 반복문은 이런 케이스에서 좀 더 코드가 복잡하다.
// 중간값을 저장하는 변수도 필요하고 등등 직관적이지 않다.
//  대신 굉장히 빠르다. 빠르다.
// 
// 
// 이러면 재귀가 진짜 구려보임.
// 최대공약수를 구할 때 반복을 쓰면?
// 두 숫자가 매우 큰 케이스에서 굉장히 오래 걸림
// 특히 서로소일 경우.
// 
// 반면, 재귀는 유클리드 알고리즘으로 매우 빠르게 숫자가 줄어든다.
// 
// 
// 
// 
